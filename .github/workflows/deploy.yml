name: PetClinic Application Deployment

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  JAVA_VERSION: '17'
  NODE_VERSION: '18'
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: petclinic
          MYSQL_DATABASE: petclinic
        ports:
          - 3306:3306
        options: --health-cmd="mysqladmin ping" --health-interval=10s --health-timeout=5s --health-retries=3

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'

      - name: Cache Maven Dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Environment Setup
        run: |
          echo "Setting up environment..."
          echo "Workspace: $GITHUB_WORKSPACE"
          echo "User: $(whoami)"
          echo "Current directory: $(pwd)"
          
          mkdir -p prometheus/data grafana/data mysql/data
          chmod -R 755 prometheus/data grafana/data mysql/data || true
          
          echo "Environment setup completed!"

      - name: Setup Spring PetClinic Project
        run: |
          echo "Setting up Spring PetClinic project..."
          
          # Check if we have Java source files
          FOUND_JAVA=$(find . -name "*.java" -type f 2>/dev/null | head -5)
          FOUND_POM=$(find . -name "pom.xml" -type f 2>/dev/null | head -5)
          FOUND_GRADLE=$(find . -name "build.gradle*" -type f 2>/dev/null | head -5)
          
          if [ -n "$FOUND_JAVA" ] || [ -n "$FOUND_POM" ] || [ -n "$FOUND_GRADLE" ]; then
              echo "Found existing Java project files"
              if [ -n "$FOUND_POM" ]; then
                  FIRST_POM=$(echo "$FOUND_POM" | head -1)
                  POM_DIR=$(dirname "$FIRST_POM")
                  echo "Setting BUILD_DIR=$POM_DIR"
                  echo "BUILD_DIR=$POM_DIR" >> $GITHUB_ENV
                  echo "PROJECT_TYPE=maven" >> $GITHUB_ENV
                  echo "BUILD_DIR set to: $POM_DIR"
              elif [ -n "$FOUND_GRADLE" ]; then
                  FIRST_GRADLE=$(echo "$FOUND_GRADLE" | head -1)
                  GRADLE_DIR=$(dirname "$FIRST_GRADLE")
                  echo "Setting BUILD_DIR=$GRADLE_DIR"
                  echo "BUILD_DIR=$GRADLE_DIR" >> $GITHUB_ENV
                  echo "PROJECT_TYPE=gradle" >> $GITHUB_ENV
                  echo "BUILD_DIR set to: $GRADLE_DIR"
              fi
          else
              echo "No Java project found. Downloading Spring PetClinic..."
              
              # Clone the official Spring PetClinic project
              git clone https://github.com/spring-projects/spring-petclinic.git temp-petclinic
              
              # Create src directory structure in petclinic-project
              mkdir -p petclinic-project/src
              
              # Copy the Java project files to petclinic-project
              if [ -d "temp-petclinic" ]; then
                  cp -r temp-petclinic/src petclinic-project/
                  cp temp-petclinic/pom.xml petclinic-project/
                  cp temp-petclinic/mvnw petclinic-project/
                  cp temp-petclinic/mvnw.cmd petclinic-project/
                  cp -r temp-petclinic/.mvn petclinic-project/
                  
                  # Copy additional files if they exist
                  [ -f "temp-petclinic/README.md" ] && cp temp-petclinic/README.md petclinic-project/README-petclinic.md
                  
                  # Remove temporary directory
                  rm -rf temp-petclinic
                  
                  echo "Spring PetClinic project has been set up in petclinic-project/"
                  echo "Setting BUILD_DIR=petclinic-project"
                  echo "BUILD_DIR=petclinic-project" >> $GITHUB_ENV
                  echo "PROJECT_TYPE=maven" >> $GITHUB_ENV
                  echo "BUILD_DIR set to: petclinic-project"
                  
                  # Verify the files were copied correctly
                  echo "Verifying copied files:"
                  ls -la petclinic-project/
              else
                  echo "Failed to download Spring PetClinic project"
                  exit 1
              fi
          fi
          
          # Also set up docker-compose file location
          FOUND_COMPOSE=$(find . -name "docker-compose.yml" -type f 2>/dev/null | head -5)
          if [ -n "$FOUND_COMPOSE" ]; then
              FIRST_COMPOSE=$(echo "$FOUND_COMPOSE" | head -1)
              echo "COMPOSE_FILE=$FIRST_COMPOSE" >> $GITHUB_ENV
          else
              echo "COMPOSE_FILE=" >> $GITHUB_ENV
          fi
          
          # Debug: Show what was written to GITHUB_ENV
          echo ""
          echo "Environment variables set:"
          echo "BUILD_DIR: $(grep BUILD_DIR $GITHUB_ENV || echo 'not found')"
          echo "PROJECT_TYPE: $(grep PROJECT_TYPE $GITHUB_ENV || echo 'not found')"
          
          echo "Project setup completed!"

      - name: Workspace Verification  
        run: |
          echo "Verifying workspace structure after setup..."
          echo "Repository contents:"
          ls -la
          
          echo ""
          echo "Build directory: ${BUILD_DIR:-not set}"
          echo "Project type: ${PROJECT_TYPE:-not set}"
          echo "Compose file: ${COMPOSE_FILE:-not set}"
          
          if [ -n "${BUILD_DIR}" ] && [ -d "${BUILD_DIR}" ]; then
              echo ""
              echo "Contents of build directory (${BUILD_DIR}):"
              ls -la "${BUILD_DIR}/"
              
              echo ""
              echo "Checking for Java project files in ${BUILD_DIR}:"
              cd "${BUILD_DIR}"
              echo "pom.xml: $([ -f pom.xml ] && echo 'Found' || echo 'Missing')"
              echo "src directory: $([ -d src ] && echo 'Found' || echo 'Missing')"
              echo "mvnw: $([ -f mvnw ] && echo 'Found' || echo 'Missing')"
              
              if [ -d src ]; then
                  echo "Java source files found: $(find src -name '*.java' | wc -l) files"
              fi
              
              cd "$GITHUB_WORKSPACE"
          else
              echo "ERROR: Build directory ${BUILD_DIR} not found or not set"
              exit 1
          fi
          
          echo ""
          echo "Workspace verification completed successfully!"

      - name: Environment Tools Check
        run: |
          echo "Checking development tools..."
          
          java -version
          echo "Java is available"
          
          if command -v mvn >/dev/null 2>&1; then
              mvn --version
              echo "Maven is available"
          elif [ -f "${BUILD_DIR:-./}/mvnw" ]; then
              echo "Maven wrapper found"
              chmod +x "${BUILD_DIR:-./}/mvnw"
          else
              echo "Neither Maven nor Maven wrapper found"
              exit 1
          fi
          
          docker --version
          
          # Check for docker compose (new) or docker-compose (legacy)
          if docker compose version >/dev/null 2>&1; then
              docker compose version
              echo "Docker Compose (plugin) is available"
              echo "COMPOSE_CMD=docker compose" >> $GITHUB_ENV
          elif command -v docker-compose >/dev/null 2>&1; then
              docker-compose --version
              echo "Docker Compose (standalone) is available"
              echo "COMPOSE_CMD=docker-compose" >> $GITHUB_ENV
          else
              echo "Docker Compose not found. Installing docker-compose..."
              # Install docker-compose if not available
              sudo curl -L "https://github.com/docker/compose/releases/download/v2.24.6/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
              docker-compose --version
              echo "Docker Compose installed successfully"
              echo "COMPOSE_CMD=docker-compose" >> $GITHUB_ENV
          fi
          
          echo "All required tools are available"

      - name: Verify Project Structure
        run: |
          echo "Verifying project structure..."
          
          BUILD_PATH="${BUILD_DIR:-./}"
          cd "$BUILD_PATH"
          echo "Build directory contents:"
          ls -la
          
          echo "Checking essential files:"
          echo "pom.xml: $([ -f pom.xml ] && echo 'Found' || echo 'Missing')"
          echo "src directory: $([ -d src ] && echo 'Found' || echo 'Missing')"
          echo "mvnw: $([ -f mvnw ] && echo 'Found' || echo 'Missing')"
          echo "Dockerfile: $([ -f Dockerfile ] && echo 'Found' || echo 'Missing')"
          
          cd "$GITHUB_WORKSPACE"
          if [ -n "${COMPOSE_FILE}" ]; then
              DEPLOY_DIR=$(dirname "${COMPOSE_FILE}")
              cd "$DEPLOY_DIR"
              echo "Deploy directory contents:"
              ls -la
          fi
          
          echo "Project structure verified!"

      - name: Check Dependencies
        run: |
          echo "Checking project dependencies..."
          BUILD_PATH="${BUILD_DIR:-./}"
          cd "$BUILD_PATH"
          
          if grep -q "micrometer-registry-prometheus" pom.xml; then
              echo "Prometheus metrics dependency found"
          else
              echo "Prometheus metrics dependency not found"
              echo "Application will work but won't expose metrics endpoint"
          fi
          
          echo "Spring Boot dependencies:"
          grep -A 3 -B 3 "spring-boot-starter" pom.xml | head -20 || echo "Could not display dependencies"
          
          echo "Dependency check completed"

      - name: Build Application
        run: |
          echo "Building Spring Boot application..."
          BUILD_PATH="${BUILD_DIR:-./}"
          cd "$BUILD_PATH"
          echo "Working in: $(pwd)"
          
          if [ "${PROJECT_TYPE}" = "gradle" ]; then
              echo "Building with Gradle..."
              if [ -f "gradlew" ]; then
                  chmod +x gradlew
                  ./gradlew clean build -x test
              else
                  gradle clean build -x test
              fi
          else
              echo "Building with Maven..."
              if [ -f "mvnw" ]; then
                  chmod +x mvnw
                  echo "Using Maven wrapper..."
                  ./mvnw clean compile -DskipTests -Dmaven.test.skip=true
              else
                  echo "Using system Maven..."
                  mvn clean compile -DskipTests -Dmaven.test.skip=true
              fi
          fi
          
          echo "Application compiled successfully"

      - name: Run Tests
        run: |
          echo "Running tests..."
          BUILD_PATH="${BUILD_DIR:-./}"
          cd "$BUILD_PATH"
          
          if [ "${PROJECT_TYPE}" = "gradle" ]; then
              echo "Running tests with Gradle..."
              if [ -x "./gradlew" ]; then
                  ./gradlew test --exclude-task postgresIntegrationTests
              else
                  gradle test --exclude-task postgresIntegrationTests
              fi
          else
              echo "Running tests with Maven..."
              if [ -x "./mvnw" ]; then
                  ./mvnw test -Dtest="!PostgresIntegrationTests" -Dspring.docker.compose.skip.in-tests=true
              else
                  mvn test -Dtest="!PostgresIntegrationTests" -Dspring.docker.compose.skip.in-tests=true
              fi
          fi
          
          echo "Tests completed successfully"

      - name: Package Application
        run: |
          echo "Packaging application..."
          BUILD_PATH="${BUILD_DIR:-./}"
          cd "$BUILD_PATH"
          
          if [ "${PROJECT_TYPE}" = "gradle" ]; then
              echo "Packaging with Gradle..."
              if [ -x "./gradlew" ]; then
                  ./gradlew bootJar -x test
              else
                  gradle bootJar -x test
              fi
              echo "Generated artifacts:"
              ls -la build/libs/*.jar 2>/dev/null || echo "No JAR files found in build/libs"
          else
              echo "Packaging with Maven..."
              if [ -x "./mvnw" ]; then
                  ./mvnw package -DskipTests
              else
                  mvn package -DskipTests
              fi
              echo "Generated artifacts:"
              ls -la target/*.jar 2>/dev/null || echo "No JAR files found in target"
          fi
          
          echo "Application packaged successfully"

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: petclinic-jar
          path: |
            **/target/*.jar
            **/build/libs/*.jar
            !**/target/*-sources.jar
            !**/target/*-javadoc.jar
            !**/build/libs/*-sources.jar
            !**/build/libs/*-javadoc.jar
          retention-days: 30

  docker-build-and-deploy:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Prepare Docker Build
        run: |
          echo "Preparing Docker build environment..."
          
          # Debug: Show current environment variables
          echo "Current environment variables:"
          echo "BUILD_DIR: ${BUILD_DIR:-not set}"
          echo "PROJECT_TYPE: ${PROJECT_TYPE:-not set}"
          echo "COMPOSE_FILE: ${COMPOSE_FILE:-not set}"
          
          # If BUILD_DIR is not set, try to find it
          if [ -z "${BUILD_DIR}" ]; then
              echo "BUILD_DIR not set, attempting to find project directory..."
              
              # Look for pom.xml files
              FOUND_POM=$(find . -name "pom.xml" -type f 2>/dev/null | head -1)
              if [ -n "$FOUND_POM" ]; then
                  BUILD_PATH=$(dirname "$FOUND_POM")
                  echo "Found pom.xml at: $FOUND_POM"
                  echo "Setting BUILD_DIR to: $BUILD_PATH"
                  echo "BUILD_DIR=$BUILD_PATH" >> $GITHUB_ENV
                  export BUILD_DIR="$BUILD_PATH"
              else
                  echo "ERROR: No pom.xml found anywhere in repository"
                  echo "Repository contents:"
                  find . -maxdepth 3 -type f -name "*.xml" -o -name "*.gradle" -o -name "mvnw" | head -10
                  exit 1
              fi
          fi
          
          BUILD_PATH="${BUILD_DIR}"
          echo "Using build directory: $BUILD_PATH"
          
          # Navigate to build directory
          if [ ! -d "$BUILD_PATH" ]; then
              echo "ERROR: Build directory does not exist: $BUILD_PATH"
              echo "Available directories:"
              ls -la
              exit 1
          fi
          
          cd "$BUILD_PATH"
          echo "Changed to directory: $(pwd)"
          
          # List current directory contents
          echo "Current directory contents:"
          ls -la
          
          # Verify all required files are present
          echo ""
          echo "Verifying build files:"
          echo "pom.xml: $([ -f pom.xml ] && echo '✓ Found' || echo '✗ Missing')"
          echo "src directory: $([ -d src ] && echo '✓ Found' || echo '✗ Missing')"
          echo "mvnw: $([ -f mvnw ] && echo '✓ Found' || echo '✗ Missing')"
          
          # Check if essential files exist
          if [ ! -f "pom.xml" ]; then
              echo "ERROR: pom.xml not found in build directory: $(pwd)"
              echo "Contents of current directory:"
              ls -la
              exit 1
          fi
          
          if [ ! -d "src" ]; then
              echo "ERROR: src directory not found in build directory: $(pwd)"
              echo "Looking for src directories:"
              find . -name "src" -type d
              exit 1
          fi
          
          # Check if Dockerfile exists and is appropriate
          if [ ! -f "Dockerfile" ]; then
              echo "Creating Dockerfile for Spring Boot application..."
              
              # Create a multi-stage Dockerfile optimized for Spring Boot
              echo "FROM maven:3.8.7-eclipse-temurin-17 AS build" > Dockerfile
              echo "WORKDIR /app" >> Dockerfile
              echo "" >> Dockerfile
              echo "# Copy Maven configuration first for better caching" >> Dockerfile
              echo "COPY pom.xml ." >> Dockerfile
              echo "COPY mvnw ." >> Dockerfile
              echo "COPY .mvn .mvn" >> Dockerfile
              echo "" >> Dockerfile
              echo "# Download dependencies (this will be cached if pom.xml doesn't change)" >> Dockerfile
              echo "RUN chmod +x mvnw && ./mvnw dependency:go-offline -B" >> Dockerfile
              echo "" >> Dockerfile
              echo "# Copy source code" >> Dockerfile
              echo "COPY src ./src" >> Dockerfile
              echo "" >> Dockerfile
              echo "# Build the application" >> Dockerfile
              echo "RUN ./mvnw clean package -DskipTests" >> Dockerfile
              echo "" >> Dockerfile
              echo "# Runtime stage" >> Dockerfile
              echo "FROM openjdk:17-jdk-slim" >> Dockerfile
              echo "WORKDIR /app" >> Dockerfile
              echo "" >> Dockerfile
              echo "# Install curl for health checks" >> Dockerfile
              echo "RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*" >> Dockerfile
              echo "" >> Dockerfile
              echo "# Copy the built JAR from build stage" >> Dockerfile
              echo "COPY --from=build /app/target/*.jar app.jar" >> Dockerfile
              echo "" >> Dockerfile
              echo "# Expose port (Spring Boot default is 8080)" >> Dockerfile
              echo "EXPOSE 8080" >> Dockerfile
              echo "" >> Dockerfile
              echo "# Health check" >> Dockerfile
              echo "HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \\" >> Dockerfile
              echo "    CMD curl -f http://localhost:8080/actuator/health || exit 1" >> Dockerfile
              echo "" >> Dockerfile
              echo "# Run the application" >> Dockerfile
              echo "ENTRYPOINT [\"java\", \"-Djava.security.egd=file:/dev/./urandom\", \"-jar\", \"app.jar\"]" >> Dockerfile
              
              echo "Created optimized multi-stage Dockerfile"
          else
              echo "Dockerfile already exists, checking if it needs updates..."
              
              # Update existing Dockerfile to expose correct port
              if grep -q "EXPOSE 9200" Dockerfile; then
                  echo "Updating Dockerfile to expose correct port (8080 instead of 9200)"
                  sed -i 's/EXPOSE 9200/EXPOSE 8080/' Dockerfile
                  sed -i 's/localhost:9200/localhost:8080/g' Dockerfile
              fi
              
              echo "Dockerfile validation completed"
          fi
          
          # Make sure mvnw is executable
          if [ -f mvnw ]; then
              chmod +x mvnw
              echo "Made mvnw executable"
          fi
          
          # Final verification
          echo ""
          echo "Final verification:"
          echo "Dockerfile: $([ -f Dockerfile ] && echo '✓ Found' || echo '✗ Missing')"
          echo "All files are ready for Docker build"
          
          echo "Docker build preparation completed"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Set Environment Variables
        run: |
          if [ -f "petclinic-build/pom.xml" ]; then
              echo "BUILD_DIR=petclinic-build" >> $GITHUB_ENV
          fi
          if [ -f "petclinic-project/docker-compose.yml" ]; then
              echo "COMPOSE_FILE=petclinic-project/docker-compose.yml" >> $GITHUB_ENV
          elif [ -f "docker-compose.yml" ]; then
              echo "COMPOSE_FILE=docker-compose.yml" >> $GITHUB_ENV
          fi

      - name: Cleanup Previous Deployment
        run: |
          echo "Cleaning up previous deployment..."
          
          # Use the compose command we detected
          COMPOSE="${COMPOSE_CMD:-docker compose}"
          $COMPOSE down --remove-orphans --volumes --timeout 30 2>/dev/null || true
          
          echo "Cleaning up standalone containers..."
          docker stop prometheus grafana node-exporter mysql-exporter cadvisor petclinic-app mysql 2>/dev/null || true
          docker rm prometheus grafana node-exporter mysql-exporter cadvisor petclinic-app mysql 2>/dev/null || true
          
          echo "Cleaning up Docker resources..."
          docker system prune -f || true
          
          echo "Cleanup completed!"

      - name: Verify Docker Configuration
        run: |
          echo "Verifying Docker configuration..."
          
          COMPOSE="${COMPOSE_CMD:-docker compose}"
          COMPOSE_FILE_PATH="${COMPOSE_FILE:-docker-compose.yml}"
          
          if [ -f "$COMPOSE_FILE_PATH" ]; then
              cd "$(dirname "$COMPOSE_FILE_PATH")"
              COMPOSE_FILE="$(basename "$COMPOSE_FILE_PATH")"
              
              echo "Using Docker Compose file: $COMPOSE_FILE"
              echo "In directory: $(pwd)"
              
              if $COMPOSE -f "$COMPOSE_FILE" config >/dev/null 2>&1; then
                  echo "docker-compose.yml is valid"
              else
                  echo "docker-compose.yml has validation issues:"
                  $COMPOSE -f "$COMPOSE_FILE" config || true
              fi
              
              echo "Services defined:"
              $COMPOSE -f "$COMPOSE_FILE" config --services 2>/dev/null || echo "Could not list services"
          fi
          
          echo "Docker configuration verified"

      - name: Deploy Application Stack
        run: |
          echo "Deploying application stack..."
          
          COMPOSE="${COMPOSE_CMD:-docker compose}"
          COMPOSE_FILE_PATH="${COMPOSE_FILE:-docker-compose.yml}"
          
          if [ -n "$COMPOSE_FILE_PATH" ] && [ -f "$COMPOSE_FILE_PATH" ]; then
              cd "$(dirname "$COMPOSE_FILE_PATH")"
              COMPOSE_FILE="$(basename "$COMPOSE_FILE_PATH")"
              echo "Using existing Docker Compose file: $COMPOSE_FILE_PATH"
          else
              echo "No docker-compose.yml found, creating basic configuration..."
              COMPOSE_FILE="docker-compose.yml"
              
              # Get the build directory for proper context
              BUILD_CONTEXT="${BUILD_DIR:-./}"
              
              # Create docker-compose.yml using echo commands
              echo "version: '3.8'" > docker-compose.yml
              echo "" >> docker-compose.yml
              echo "services:" >> docker-compose.yml
              echo "  mysql:" >> docker-compose.yml
              echo "    image: mysql:8.0" >> docker-compose.yml
              echo "    container_name: mysql" >> docker-compose.yml
              echo "    environment:" >> docker-compose.yml
              echo "      MYSQL_ROOT_PASSWORD: petclinic" >> docker-compose.yml
              echo "      MYSQL_DATABASE: petclinic" >> docker-compose.yml
              echo "    ports:" >> docker-compose.yml
              echo "      - \"3306:3306\"" >> docker-compose.yml
              echo "    volumes:" >> docker-compose.yml
              echo "      - mysql_data:/var/lib/mysql" >> docker-compose.yml
              echo "    healthcheck:" >> docker-compose.yml
              echo "      test: [\"CMD\", \"mysqladmin\", \"ping\", \"-h\", \"localhost\"]" >> docker-compose.yml
              echo "      timeout: 20s" >> docker-compose.yml
              echo "      retries: 10" >> docker-compose.yml
              echo "" >> docker-compose.yml
              echo "  petclinic-app:" >> docker-compose.yml
              echo "    build:" >> docker-compose.yml
              echo "      context: $BUILD_CONTEXT" >> docker-compose.yml
              echo "      dockerfile: Dockerfile" >> docker-compose.yml
              echo "    container_name: petclinic-app" >> docker-compose.yml
              echo "    ports:" >> docker-compose.yml
              echo "      - \"9500:8080\"" >> docker-compose.yml
              echo "    environment:" >> docker-compose.yml
              echo "      - SPRING_PROFILES_ACTIVE=mysql" >> docker-compose.yml
              echo "      - SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/petclinic" >> docker-compose.yml
              echo "      - SPRING_DATASOURCE_USERNAME=root" >> docker-compose.yml
              echo "      - SPRING_DATASOURCE_PASSWORD=petclinic" >> docker-compose.yml
              echo "    depends_on:" >> docker-compose.yml
              echo "      mysql:" >> docker-compose.yml
              echo "        condition: service_healthy" >> docker-compose.yml
              echo "" >> docker-compose.yml
              echo "volumes:" >> docker-compose.yml
              echo "  mysql_data:" >> docker-compose.yml
              
              echo "Created basic docker-compose.yml"
          fi
          
          if [ -d "alertmanager.yml" ]; then
              echo "Found directory instead of file: alertmanager.yml"
              rm -rf alertmanager.yml
              echo "Removed alertmanager.yml directory"
          fi
          
          mkdir -p alertmanager
          mkdir -p grafana/provisioning/datasources
          mkdir -p grafana/provisioning/dashboards
          mkdir -p prometheus/data grafana/data mysql/data
          
          echo "global:" > alertmanager.yml
          echo "  smtp_from: alertmanager@localhost" >> alertmanager.yml
          echo "  smtp_smarthost: localhost:587" >> alertmanager.yml
          echo "  smtp_require_tls: false" >> alertmanager.yml
          echo "" >> alertmanager.yml
          echo "route:" >> alertmanager.yml
          echo "  group_by: ['alertname']" >> alertmanager.yml
          echo "  receiver: 'default-receiver'" >> alertmanager.yml
          echo "" >> alertmanager.yml
          echo "receivers:" >> alertmanager.yml
          echo "  - name: 'default-receiver'" >> alertmanager.yml
          echo "    email_configs:" >> alertmanager.yml
          echo "      - to: 'admin@example.com'" >> alertmanager.yml
          echo "        send_resolved: true" >> alertmanager.yml
          
          echo "Created alertmanager.yml configuration file"
          
          chmod -R 755 . 2>/dev/null || true
          chmod 644 alertmanager.yml
          
          echo "Building Docker images..."
          echo "Build context: $(pwd)"
          echo "Compose file: $COMPOSE_FILE"
          echo "Build directory: ${BUILD_DIR}"
          
          # If we have a specific build directory, we need to adjust the build context
          if [ -n "${BUILD_DIR}" ] && [ "${BUILD_DIR}" != "./" ] && [ "${BUILD_DIR}" != "." ]; then
              echo "Adjusting docker-compose.yml for build directory: ${BUILD_DIR}"
              
              # Update the docker-compose.yml to use correct build context
              if [ -f "$COMPOSE_FILE" ]; then
                  # Replace context path in existing compose file
                  sed -i "s|context: \.|context: ${BUILD_DIR}|g" "$COMPOSE_FILE"
                  sed -i "s|dockerfile: Dockerfile|dockerfile: ${BUILD_DIR}/Dockerfile|g" "$COMPOSE_FILE"
                  echo "Updated docker-compose.yml build context"
              fi
          fi
          
          # Show the final compose file for debugging
          echo "Final docker-compose.yml content:"
          cat "$COMPOSE_FILE"
          
          $COMPOSE -f "$COMPOSE_FILE" build --no-cache
          
          echo "Starting all services..."
          $COMPOSE -f "$COMPOSE_FILE" up -d
          
          echo "Deployment completed"

      - name: Health Checks
        run: |
          echo "Performing comprehensive health checks..."
          
          check_service() {
              local service_name=$1
              local url=$2
              local max_attempts=$3
              local expected_pattern=$4
              
              echo "Checking $service_name..."
              for i in $(seq 1 $max_attempts); do
                  echo "Attempt $i/$max_attempts for $service_name"
                  
                  if curl -s --connect-timeout 10 --max-time 15 "$url" 2>/dev/null | grep -q "$expected_pattern"; then
                      echo "$service_name is healthy!"
                      return 0
                  fi
                  
                  if [ $i -eq $max_attempts ]; then
                      echo "$service_name health check timeout after $max_attempts attempts"
                      echo "Last response from $url:"
                      curl -s --connect-timeout 5 "$url" 2>/dev/null | head -3 || echo "No response"
                      return 1
                  fi
                  
                  sleep 10
              done
          }
          
          echo "Waiting for all services to fully initialize..."
          sleep 30
          
          echo "Starting health checks..."
          
          check_service "PetClinic App" "http://localhost:9500/actuator/health" 20 "UP" || \
          check_service "PetClinic App (fallback)" "http://localhost:9500" 10 "PetClinic" || \
          echo "PetClinic app check completed with warnings"
          
          check_service "Prometheus" "http://localhost:9090/-/ready" 15 "Prometheus" || \
          check_service "Prometheus (fallback)" "http://localhost:9090" 10 "Prometheus" || \
          echo "Prometheus check completed with warnings"
          
          check_service "Grafana" "http://localhost:3000/api/health" 15 "ok" || \
          check_service "Grafana (fallback)" "http://localhost:3000/login" 10 "Grafana" || \
          echo "Grafana check completed with warnings"
          
          if curl -s --connect-timeout 5 http://localhost:9100/metrics | head -1 | grep -q "node_"; then
              echo "Node Exporter is providing metrics"
          else
              echo "Node Exporter metrics not available"
          fi
          
          if nc -z localhost 3306 2>/dev/null; then
              echo "MySQL port is accessible"
          else
              echo "MySQL port not accessible"
          fi
          
          echo "Health checks completed!"

      - name: Final Deployment Report
        run: |
          echo "=========================================="
          echo "    DEPLOYMENT STATUS REPORT"
          echo "=========================================="
          
          COMPOSE="${COMPOSE_CMD:-docker compose}"
          COMPOSE_FILE_PATH="${COMPOSE_FILE:-docker-compose.yml}"
          
          if [ -f "$COMPOSE_FILE_PATH" ]; then
              cd "$(dirname "$COMPOSE_FILE_PATH")"
              COMPOSE_FILE="$(basename "$COMPOSE_FILE_PATH")"
              
              echo "Final Container Status:"
              $COMPOSE -f "$COMPOSE_FILE" ps
          fi
          
          echo ""
          echo "Service Endpoints:"
          echo "PetClinic Application: http://localhost:9500"
          echo "Health Check: http://localhost:9500/actuator/health"
          echo "Metrics: http://localhost:9500/actuator/prometheus"
          echo "Grafana Dashboard: http://localhost:3000"
          echo "Default Login: admin/admin123"
          echo "Prometheus Metrics: http://localhost:9090"
          echo "Targets: http://localhost:9090/targets"
          echo "Node Exporter: http://localhost:9100/metrics"
          echo "MySQL Database: localhost:3306"
          
          echo ""
          echo "Management Commands:"
          echo "View logs: ${COMPOSE_CMD:-docker compose} logs [service-name]"
          echo "Stop services: ${COMPOSE_CMD:-docker compose} down"
          echo "Restart service: ${COMPOSE_CMD:-docker compose} restart [service-name]"
          
          echo ""
          echo "DEPLOYMENT COMPLETED SUCCESSFULLY!"

      - name: Save Deployment Logs
        if: always()
        run: |
          echo "Collecting deployment logs..."
          mkdir -p logs
          
          COMPOSE="${COMPOSE_CMD:-docker compose}"
          COMPOSE_FILE_PATH="${COMPOSE_FILE:-docker-compose.yml}"
          if [ -f "$COMPOSE_FILE_PATH" ]; then
              cd "$(dirname "$COMPOSE_FILE_PATH")"
              COMPOSE_FILE="$(basename "$COMPOSE_FILE_PATH")"
              $COMPOSE -f "$COMPOSE_FILE" logs > "$GITHUB_WORKSPACE/logs/docker-compose.log" 2>&1 || true
          fi
          
          docker logs petclinic-app > logs/petclinic-app.log 2>&1 || true
          docker logs prometheus > logs/prometheus.log 2>&1 || true
          docker logs grafana > logs/grafana.log 2>&1 || true
          docker logs mysql > logs/mysql.log 2>&1 || true
          
          echo "Logs collected"

      - name: Upload Deployment Logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-logs
          path: logs/
          retention-days: 7

  cleanup:
    needs: [build-and-test, docker-build-and-deploy]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Cleanup Resources
        run: |
          echo "=========================================="
          echo "       WORKFLOW EXECUTION SUMMARY"
          echo "=========================================="
          echo "Run ID: ${{ github.run_id }}"
          echo "Repository: ${{ github.repository }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"
          echo "Actor: ${{ github.actor }}"
          echo "Timestamp: $(date)"
          echo "Event: ${{ github.event_name }}"
          
          if [ "${{ needs.docker-build-and-deploy.result }}" == "success" ]; then
              echo ""
              echo "SUCCESS! Your PetClinic application is now running!"
              echo ""
              echo "Spring PetClinic Application: DEPLOYED"
              echo "MySQL Database: RUNNING"
              echo "Prometheus Monitoring: ACTIVE" 
              echo "Grafana Dashboards: AVAILABLE"
              echo "Node Exporter: COLLECTING METRICS"
              echo ""
              echo "Quick Access URLs:"
              echo "• Application: http://localhost:9500"
              echo "• Monitoring: http://localhost:3000 (admin/admin123)"
              echo "• Metrics: http://localhost:9090"
          elif [ "${{ needs.docker-build-and-deploy.result }}" == "failure" ]; then
              echo ""
              echo "DEPLOYMENT FAILED - Check the logs for details"
              echo ""
              echo "Common Issues:"
              echo "1. Port conflicts - Check if ports 9500, 3000, 9090, 3306 are available"
              echo "2. Docker resources - Try docker system prune -f"
              echo "3. Memory issues - Check available memory"
          fi
          
          echo ""
          echo "=========================================="
          echo "    CLEANUP COMPLETED"
          echo "=========================================="